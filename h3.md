# h3 - Cyber lab

## 1\. Cracking Passwords with Hashcat

### 1.1. Scenario 1: Dictionary Attack

1\. For me the assignment starts with switching to the root user with this command (followed by entering a system password):

```su -```

2\. Then, we need to type the following command:

```sudo apt-get update```

Where:

-   ```sudo``` — command needed for root privileges, in cases of making system-wide changes.
    
-   ```apt-get``` — command for managing packages in Debian
    
-   ```update``` — command to refresh package index.
    
Notably, it doesn’t actually download or upgrade installed software.

3\. We should type another line:

```sudo apt-get -y install hashid hashcat wget```

Where (new components):

-   ```-y``` — a flag to automatically reply “yes” to any prompts during the software installation process.
    
-   ```install``` — command for downloading, unpacking and installing a specified package.
    
-   ```hashid``` — tool for identifying a type of hash. Required for Hashcat to work properly.
    
-   ```hashcat``` — hashcat is one of the most popular tools for password recovery that uses advanced algorithms to specifically crack password hashes.
    
-   ```wget``` — utility for downloading files from the web.

Observing the print output after the command (the Hashcat package has been previously installed):

![h3-1](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-1.png)

4\. We create the new directory (folder) called “hashed”, and move to that directory with the 2 commands below:

```mkdir hashed```
```cd hashed```

5\. Now, we need to download the database of simple or leaked passwords called Rockyou (more than 14 million password combinations in total), which is stored and read as a simple text file. The package can be downloaded from Github using wget:

wget [https://github.com/danielmiessler/SecLists/raw/master/Passwords/Leaked-Databases/rockyou.txt.tar.gz](https://github.com/danielmiessler/SecLists/raw/master/Passwords/Leaked-Databases/rockyou.txt.tar.gz)

By the output, we can see that the file was successfully saved:

![h3-2](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-2.png)

6\. Because the file is compressed, to work with it, we need to unzip it first using the following commands:

```tar xf rockyou.txt.tar.gz```

```rm rockyou.txt.tar.gz```

Where:

-   ```tar``` — command used for working with archive files
    
-   ```x``` — a flag prescribing to unpack a given file
    
-   ```f``` — another flag that tells that the next argument is the file name to operate on.
    
-   ```rockyou.txt.tar.gz``` — exact name of the archive file.
    
-   ```rm``` — this command deletes the file, in this case the archive file we unpacked (stored as a separate file).
    
Why do we need a dictionary? A dictionary, or a database of passwords, is needed for Hashcat to figure out the target password by its hash. Because hash can be reverse-engineered back to a password, software needs a dictionary as a list of examples: it converts passwords into hashes using the same hash algorithm as the target password. When it finds a match, it figures the password.

7\. After that, we can try hashid that needs for figuring out hash types, by checking it against a sample hash:

```hashid -m 6b1628b016dff46e6fa35684be6acc96```

It give the following response:

![h3-3](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-3.png)

In particular, the program presents a list of possible hash types used for the analyzed hash value. To find the actual type, the one who cracks the password should ideally know the context in which the password was created in the first place. 

8\. Now, we can try cracking the hashed password by checking its hash against the dictionary using the MD5 hash type:

hashcat -m 0 '6b1628b016dff46e6fa35684be6acc96' rockyou.txt -o solved

Where:

-   ```hashchat``` — command to use the Hashcat
    
-   ```-m 0``` — flag to specify the hash mode (in this case 0, corresponding to MD5).
    
-   ```'...'``` — hash value.
    
-   ```-o solved``` — save the solution as a plain text in a new file named “solved”
    

In the output, we see the message that Hashcat has successfully cracked the given hash, and after checking the value saved in “solved”, we can see it is “summer”:

![h3-4](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-4.png)

### 1.2. Scenario 2: Rule-based Attack

Another type of attack we can try using Hashcat is a Rule-based attack. It also includes the Rockyou dictionary but applies a set of rules to every expression, following common social engineering tactics (e.g. add “1” in the end). Hashcat has a basic ruleset called “best64” that applies multiple “mutations” (changes) to dictionary passwords. It is essentially a method for drastic increase the volume of entries in the dictionary, to potentially cover more cases.

1\. We start by creating a new hash for the password “summer123”:

```echo -n "summer123" | md5sum```

Where ```md5sum``` is the hash type.

Next, we do the cracking using Hashcat’s “best64” rule:

```hashcat -m 0 -a 0 '6b1628b016dff46e6fa35684be6acc96' rockyou.txt -r /usr/share/hashcat/rules/best64.rule```

It successfully cracks the password from the first attempt:

![h3-5](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-5.png)

Because I didn’t save the cracked password, I can check it by typing the command:

```hashcat -m 0 --session=hashcat '6b1628b016dff46e6fa35684be6acc96' --show```

It gives me the correct target password:

![h3-6](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-6.png)

## 2\. Crack File Password With John

This part is about cracking a file password using another tool called John the Ripper.

1\. First, we need to install all the prerequisites, as per the assignment:

```sudo apt-get -y install micro bash-completion git build-essential libssl-dev zlib1g zlib1g-dev zlib-gst libbz2-1.0 libbz2-dev atool zip wget```

2\. Next, we install the package from GitHub:

```git clone --depth=1 https://github.com/openwall/john.git```

3\. We now need to run the config using the command (previously transferring to John’s directory):

```./configure```

4\. Some optional libraries were missing. The program proposed to compile them by running:

```make -s clean && make -sj10```

5\. Then, move to the folder “run” and list executables:

```ls -1```

6\. Now, return home and run the software:

```$HOME/hashed/john/run/john```

We get the version in the output:

![h3-7](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-7.png)

7\. Now, we need to install the sample zip archive:

```wget https://TeroKarvinen.com/2023/crack-file-password-with-john/tero.zip```

8\. I try opening it - nothing:

![h3-8](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-8.png)

We need to crack the password to this archive using John with a two-step process.

9\. As a first step, we extract the password’s hash into a new file called tero.zip.hash:

```$HOME/hashed/john/run/zip2john tero.zip > tero.zip.hash```

10\. Second, we perform the attack on the hash:

```$HOME/hashed/john/run/john tero.zip.hash```

It prints output with one key line (highlighted in red), the password is “butterfly”: 

![h3-9](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-9.png)

11\. Now, checking content of the file inside the archive:

![h3-10](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-10.png)

12\. Now, I try to run the sequence again:

1.  Create a file (flag.txt).    
2.  Archive it into a secret.zip.    
3.  Move it under a password (sisukas).    
4.  Extract password’s hash (secret.hash).    
5.  Finally, conduct an attack against it.

The command sequence:

![h3-11](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-11.png)

Output with the cracked password:

![h3-12](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h3-12.png)

