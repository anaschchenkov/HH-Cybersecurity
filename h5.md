# h5 Alice and Bob

Writing the assignment h5 \[1\] made me think first: what is cryptography? Reading through different definitions \[2\], I worked out my own, here it is:

Cryptography is a discipline (or science) of using various mathematical algorithms for transforming human-readable information and data into unreadable format (and vice versa), ensuring that information remains accessible only to authorized readers. In software, cryptography is mostly used for transferring sensitive data from a sender to a receiver in a safe manner, while also verifying user identities, and ensuring that information or data have not been changed.

Now, moving on to the part of book “Applied Cryptography: Protocols, Algorithms and Source Code in C” by Bruce Schneier \[3\] about terminology of cryptography.

## Chapter 1.1 “Terminology”

### Cryptography as the communication model

Part 1.1 “Terminology” covers fundamental concepts and terms of this field. It explains that all cryptography at its core is about communication between a sender and a receiver. They exchange messages, encrypted so that no one else could understand what the message is about.

This process includes several concepts:
-   **Plaintext**: the original message that can be anything (text, audio, video, etc.) in a digital form (binary code).
-   **Ciphertext**: enrypted, unreadable version of this message.
-   **Encryption**: the function that turns plaintext into ciphertext.
-   **Decryption**: the function that turns ciphertext back into plaintext.
   
There also different roles and disciplines:
- **Cryptography**: the science aimed at keeping messages secure
- **Cryptanalysis**: the discipline aimed at breaking cryptography-based security methods (deciphering messages without keys)    
- **Cryptology**: the part of math that covers both these disciplines    

### Goals of cryptography

Although keeping messages confidential is the main goal of cryptography, there are also other goals. In particular, it enables authentication, i.e. the ability to verify the origin of the message. In other words, it ensures (and can check) the sender’s identity.

Another goal is integrity: cryptography ensures that message’s content is not changed in a process of transfer from a sender to a receiver. Essentially, it ensures there are no false messages.

Finally, one more goal of cryptography is nonrepudiation, or preventing the sender from denying that he was the one who sent the message in the future.

### Algorithms

Cryptography relies on ciphers, i.e. mathematical functions used for encryption. Historically, there were restricted algorithms, when the security was about keeping the function (method of encryption) secret. Without sophisticated decryption tools, they had utility, but at the same time they were fragile because once an algorithm is found or figured, it becomes obsolete.

Modern cryptography systems rely on key-based algorithms, when an algorithm itself is public but the actual key (ways to correctly “translate” encrypted data back into an original message) is unknown and, ideally, cannot be found or calculated, at least with current computational resources. Each key has a number of possible values, or keyrange. 

Having algorithms public allowed for using certain proven methods on a large scale without the risk of compromising keys, while also studying and improving them.

There are two main types of key-based algorithms: **symmetric** and **public-key (asymmetric)**.

Symmetric algorithms usually use 1 key, or a set of keys that can be easily calculated from each other. Sender and receiver must agree on the secret key before communicating.

Public-key algorithms use two different keys: **public** and **private**. The key for encryption is public, while the key for decryption is private, only the receiver has it.

While symmetric algorithms are equal to safe box, to which both sender and receiver have a key, assymetric ones act more like a mailbox: anyone who uses the same algorithm can send a message (encryption), but only the receiver has a key to his “mail box”, i.e. can read those messages.

## Chapter 2.5 Communication Using Public-Key Cryptography

The chapter follows the safe/mailbox analogy but with additional context.  

So, in symmetric algorithms (safes), if you have a key to a safe, you can get the document out of the safe, but you can also put another message inside. 

In asymmetric algorithms, anyone puts a “mail” (message) inside, but only the receiver (mailbox owner) will be able to “open the letter”, i.e. read incoming messages. 

One more important concept in the context of public-key algorithms is **“trapdoor”**, a special kind of one-way function: it is easy to perform in one direction but very hard to impossible to reverse without a secret (key). Schneier compares this process to disassembling a watch: while anyone can easily break a watch into hundreds of tiny pieces, putting it back together is extremely difficult unless you possess the specific assembly instructions. 

In public-key cryptography, only a receiver (owner of the mailbox) has “instructions” (trapdoor) to put the pieces of this “broken watch” (i.e. encrypted message) back together, i.e. decrypt it. That’s what makes a public-key algorithm secure.

### Hybrid cryptosystem

The main disadvantage of asymmetric algorithms compared to symmetric ones is that the former are slow. Thus, they are rarely used separately. Instead, most modern cryptographic systems are hybrid, i.e. use a combination of asymmetric and symmetric algorithms.

Using the popular Alice/Bob analogy, the author provides an example of a hybrid cryptography:

1.  Bob sends Alice his public key.    
2.  Alice generates a temporary session key, which is symmetric.    
3.  Alice encrypts the session key using Bob’s public Key and sends it to him.    
4.  Bob decrypts Alice’s message with his private key. Now, they both have the session key.    
5.  They use the fast session key to encrypt their actual conversation.  

This solves the key management problem: how to share a secret key while keeping the speed of symmetric encryption.

## Chapter 2.6 “Digital Signatures” 

As was mentioned above, one of cryptography’s main goals is authentication, i.e. proving the identity of a sender and that it fits the algorithm’s requirements.  

In our daily life, we can sign documents using our unique handwritten signatures. In software, a similar method with digital signatures is used.  

Digital signatures are needed for verifying the authenticity and integrity of a message. They function by reversing the standard roles of public-key cryptography: the sender encrypts the document using their private key rather than the recipient’s public key. 

Because the private key is secret and unique to the sender, anyone can use the sender’s public key to decrypt the signature. If the decryption works, it proves that the message originated from the sender (authenticity) and has not been altered in transit (integrity), preventing the sender from later denying they sent it (non-repudiation).

### Hash functions

To make this process efficient, modern protocols rarely sign the entire document because public-key algorithms are slow. Instead, they use a one-way hash function to create a tiny, unique “fingerprint” of the document and sign only that hash. 

### Replay attacks and digital checks

Furthermore, to prevent so-called replay attacks, where an attacker intercepts a valid signed message (like a digital check) and resends it later, digital signatures are often combined with timestamps. This ensures that even if a valid signature is copied, it cannot be reused maliciously at a later time.

### Digital signature trees

A scientist Ralph Merkle proposed an alternative to using public-key algorithms for signature: secret-key symmetric cryptography. He created a tree-like structure where a root key is published to a public file to authenticate the whole “tree”. Each branch and node in the tree can then be used to generate a secure, one-time signature.

### Multiple signatures

If Alice and Bob both need to sign the same document, doing so without hash functions is not suitable (e.g. the file size doubles, or one signature gets wrapped inside the other).

With hash functions, this becomes easy. Both Alice and Bob sign the same hash. A third party (“Carol”) can verify Alice’s signature and Bob’s signature independently of one another.

### Nonrepudiation and Timestamps

A sender (Alice) could try to cheat by intentionally “losing” her private key, publishing it anonymously, and then claiming that her previous signatures were fake. This is called “repudiation”.

Trusted timestamps help prevent this. When Alice signs a document, she sends it to a trusted entity who adds a timestamp and signs it again. This proves that the document existed before Alice “lost” her key, preventing her from invalidating old contracts.

## PGP

Now, on to the article about PGP by T.Karvinen \[4\].

PGP (Pretty Good Privacy) allows users to communicate securely over untrusted networks by providing both confidentiality and authenticity. 

At the core of this system is the keypair: every user generates a public key that can be shared openly and a secret private key that remains secure. 

The public key allows others to encrypt messages destined for the owner, while the private key is required to decrypt them. 

Before secret communication can begin, users must establish trust. For that, they exchange public keys, usually written in a certain format, and verify them. 

The verification process includes checking the key’s nique fingerprint to ensure the key actually belongs to the intended person. After the verification is completed, the key becomes trusted in the user’s system.
  
When sending a secure message, the process involves both encryption and digital signatures. The sender (Alice) encrypts the message using the recipient’s (Tero) public key, ensuring that only the recipient can read it. 

Simultaneously, Alice signs the message using her own private key to prove her identity and ensure the message has not been modified. Upon receipt, the recipient uses their own private key to decrypt and read the message, while the software automatically uses the sender's public key to verify the digital signature. A “Good signature” confirmation assures the recipient that the message is authentic and unaltered.

### Conclusions

Here are my conclusions about PGP in the context of the previously reviewed book material:

1.  PGP is the real-world application of the “mailbox” analogy and trapdoor functions: it uses the recipient’s public key for encryption and the sender’s private key for digital signatures (authenticity).    
2.  Instead of the centralized arbitrator model, where signatures can be checked by a trusted third-party, PGP uses a decentralized model. Trust is established by manually verifying fingerprints (key hashes), eliminating the need for a central authority to manage all keys.    
3.  PGP solves the main problem of distributing symmetric keys: it allows two parties of communication to establish a secure channel over an untrusted network (e.g. Web) without ever having to exchange a secret.    
4.  Although PGP uses methods of public-key algorithms, it is essentially a hybrid system: it uses the public key to exchange a temporary symmetric session key, which is then used to encrypt the message.    
5.  Finally, PGP allows for achieving all three goals of cryptography in a single design. It combines encryption and signing, it ensures the message is secret (confidentiality), the sender is verified (authentication), and the content has not been altered (integrity).

***a) Pubkey today. Explain how you have used public key cryptography today or yesterday, outside of this homework. In addition to naming the system, identify how different parties use keys in different steps of the system. (Answering this question likely requries finding sources on your own. This subtask does not require tests with a computer.)***

1\. HTTPS. Modern websites use the version of the HTTP protocol where all data exchanged with a web server is encrypted for enhanced security \[5\]. When I visit any website, the web server sends a public key to my browser using a digital certificate. My browser verifies the identity of this server using its public key. Then, my browser generates a session key, and sends it to the server. The server uses the private key to decrypt the message and retrieve the session key. Then both sides use the session key (symmetric algorithm) to encrypt communication.

2\. Messaging in WhatsApp. WhatsApp employs end-to-end encryption \[6\] for user chats. When I chat with my friend in WhatsApp, we exchange encrypted data. Both my and my friend’s keys are uploaded to WhatsApp server. When I send a message to my friend, my phone gets his public key from the server to encrypt the message. Only my friend’s device can decrypt it using its private key. However, there are concerns \[7\] that communication is not fully private and Meta collects detailed metadata on every message (like a timestamp and location), and/or is able to retrieve key pairs if needed (e.g. a police request).

***b) Encrypt a message. Explain how different parties use different keys at different stages of operation. Evaluate the security of the tool you've chosen.***

***c) Eve and Mallory. In many crypto stories, Eve is a passive eavesdropper, listening on the wire. Mallory malliciously modifies the messages. Explain how PGP protects against Mallory and Eve. Be specific what features, which use of keys and which flags in the command are related to this protection. (This subtasks does not require tests with a computer)***

PGP protects against eavesdropping through encryption (flag --encrypt) using the receiver’s public key, which ensures that only the holder of the corresponding private key can read the message. 

It protects the message against modification of its content through digital signatures (flag --sign) using the sender’s private key, which allows the recipient to verify that the message actually came from the sender and has not been changed while in transit.

***d) Password management. Demonstrate use of a password manager. What kind of attacks take advantage of people not using password managers? (You can use any password manager, some examples include pass and KeePassXC.)***

We can think of login credentials as a key pair of login and password.

The password manager is accessed using the “main” password that gives access to all other credentials.

When registering on a new website (e.g. online store), the password manager generates a unique password using a random combination of characters and digits. It then stores this password, along with some additional data (e.g. a website address) So, when logging in to this website next time, I summon the password from the password manager by auto-typing it.

Thus, a password manager can protect against basic attacks:

Dictionary or brute-force attacks (learned in the previous lessons), when a password is figured using automated software that checks massive dictionaries and combinations. When I manually create a password, I come up with something simple and predictable (like real vocabulary words) to make this password memorable. Such a password has low entropy, or randomness. It makes it very weak against this simple kind of attack.

Credential stuffing attacks \[8\], when one password is used for multiple websites. That’s how many databases of leaked credentials work: hackers use them to try to get into multiple resources potentially belonging to the same user, thinking that he can use a single password for all his accounts. Websites that give access to payment data (like ecommerce, banks, subscription services) are especially interesting to hackers in the case of reuse attacks.

***e) Refer to sources. Verify each homework report (this and the earlier ones) refers to sources. Every homework report should refer to this task page. It should also have references to any other source used, such as web pages, LLMs, man pages, other reports... References are mandatory, and must be present in every report. (This subtask does not need a report, you can just do it and write "Done." as the answer for this subtask.)***

Done

***f) Voluntary: Details of PGP. Send an encrypted and signed message using PGP, then verify and decrypt it. (You can use folders to simulate users, or use two computers or two different OS users. Don't use Tero as a name of any party, unless that's your given name. Many tools automate the use of PGP, my article allows you to do each step by hand.)***

I will follow the guidance in the article “PGP - Send Encrypted and Signed Message - gpg” \[4\].

1\. Install PGP:

``sudo apt-get update
sudo apt-get install gpg micro psmisc``

2\. Create a key pair:  

``gpg --gen-key``

![h5-1](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-1.png)

3\. Create a fingerprint:

``gpg --fingerprint``

![h5-2](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-2.png)

4\. Export the public key:

``cd
gpg --export --armor --output fedor.pub``

5\. Check the exported key:

``ls
tero.pub
head -4 tero.pub``

![h5-3](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-3.png)

6\. Create a simulated Alice, move to her directory, generate her fingerprint:

``cd
mkdir alice/
chmod og-rwx alice/
cd alice/
gpg --homedir . --fingerprint``

![h5-4](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-4.png)

7\. Generate a key pair for Alice:

``gpg --homedir . --gen-key``

![h5-5](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-5.png)

8\. Check Alice’s keyring:

``gpg --homedir . --fingerprint``

9\ Clone Fedor’s public key to Alice’s directory, check his fingerprint:

![h5-6](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-6.png)


``cd
cp -v tero.pub alice/
cd alice/
gpg --homedir . --fingerprint``

![h5-7](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-7.png)

10\. Verify the signature:

``gpg --homedir . --sign-key "..."``

![h5-8](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-8.png)

11\. Clone Alice’s public key and send it:

``gpg --homedir . --export --armor --output alice.pub
cp -v alice/alice.pub .
cd 
cp -v alice/alice.pub .``

![h5-9](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-9.png)

12\. Import the Alice’s public key to Fedor’s:

``gpg --import alice.pub``

![h5-10](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-10.png)

13\. Verify Alice’s fingerprint:

``gpg --sign-key "..."``

![h5-11](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-11.png)

``gpg --fingerprint``

![h5-12](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-12.png)

14\. Alices writes a message:

``cd ~/alice/
micro message.txt``

![h5-13](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-13.png)

15. Encrypt and sign the message, check its presence and content:
``gpg --homedir . --encrypt --recipient anashchenkov@gmail.com --sign --output encrypted.pgp --armor message.txt
ls encrypted.pgp
head -4 encrypted.pgp``

![h5-14](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-14.png)

16\. Send the message and check it:

``cd
cp -v alice/encrypted.pgp .
gpg --decrypt encrypted.pgp``

![h5-15](https://github.com/anaschchenkov/HH-Cybersecurity/blob/main/pics/h5/h5-15.png)

## References

[1] “Cyber Security - 2025 late autumn - ICB705AS3YE-1 +cy.” Accessed: Nov. 26, 2025. [Online]. Available: https://terokarvinen.com/cyber-security/#homework

[2]	K. Richards, “What is cryptography?,” TechTarget, Mar. 13, 2024. Accessed: Nov. 26, 2025. [Online]. Available: https://www.techtarget.com/searchsecurity/definition/cryptography

[3]	B. Schneier, Applied Cryptography: Protocols, Algorithms, and Source Code in C. 2015.

[4]	“PGP - Send Encrypted and Signed Message,” gpg. Accessed: Nov. 26, 2025. [Online]. Available: https://terokarvinen.com/2023/pgp-encrypt-sign-verify/

[5]	“ByteByteGo,” ByteByteGo. Accessed: Nov. 26, 2025. [Online]. Available: https://bytebytego.com/guides/how-does-https-work/

[6]	S. Jain, “How WhatsApp Ensures Chat Security with End-to-End Encryption,” Requestly API Client - Free Forever & Open Source. Accessed: Nov. 26, 2025. [Online]. Available: https://requestly.com/blog/how-whatsapp-ensures-chat-security-with-end-to-end-encryption/

[7]	“Is WhatsApp lying about it’s end-to-end encryption? : r/privacy.” Accessed: Nov. 26, 2025. [Online]. Available: https://www.reddit.com/r/privacy/comments/v7tsou/is_whatsapp_lying_about_its_endtoend_encryption/

[8]	“Credential stuffing,” OWASP Foundation. Accessed: Nov. 26, 2025. [Online]. Available: https://owasp.org/www-community/attacks/Credential_stuffing
